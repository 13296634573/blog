# 弱特征广告方案

# 目标

一般浏览器拦截页面内广告会使用css选择器，比如qq浏览器的规则：

```
hide=###app_mask,##.load-app,##div[class^="bbt-pregnant-timeline bbt-pregnant-timeline-"],##div[class^="bottom-layer-"],##div[class="bbt-header-dingtong"],##div[class*="-header-pregnancy"],##div[class*="-footer-pregnancy"],##section[class$="-brand"],##section[class$="-tool"],##div[class$="-footer-expand"]
filter=/base.js?v*&method=$third-party /www/default/base.js$third-party
```
从规则可以看出，弱特征化就是将class弱特征化。

# 方案1 纯前端方案

方案描述：

1. 广告模板包括css，html和js，页面直接输出此模板
2. 广告引擎js会读取模板，并将css中的class名称替换成随机，同时替换html和js的class名称
3. 最后将替换后的模板嵌入到页面中

优势：

1. 每次算法都是随机，通过classname来定位广告基本不可能

劣势：

1. 插入html的位置不好确定，位置可能会成为新的特征
2. 广告模板是特征很强的元素，不能加密，直接输出到html中，线索被暴露了
3. 广告模板转换为真正的广告html是一个关键路径方法，理论上，可以通过上述线索较为容易的找到，找到后，浏览器引擎可以在方法执行前，将此方法置空
4. 纯前端渲染，页面会有一定时间的阻塞

总结：

被破解的线索会比较多

# 方案2 前后端结合方案

方案描述：

1. html和css中使用php函数getName(name)来定义class
2. getName中根据传入的name和盐做md5，将此md5作为返回值
3. js中实现同样的getName函数来计算真实的classname
4. js盐的获取方式要隐藏在页面中
5. 所有的js文件必须加密
6. 每个版本中可以固定一组盐，由php决定每一次的请求使用哪个盐
7. 针对每一个盐，css都会生成对应的样式

优势：

1. 因为在html中name是看不到的，只能看到classname，在js里只有name而没有classname，且js文件是加密的，所以在js中不宜搜索，不宜找到关键算法
2. 不会阻塞页面渲染
3. 盐是php定义的，在js获取盐的时候会暴露一次，理论上有暴露的可能性，但几率不高，而且就算暴露了，也还需要破解我们的加盐的位置，这在js里都是加密存放的，难度较大

劣势：

1. css文件增大，浪费了流量，这个流量不大。
2. js编码复杂一些，不过广告功能一般比较简单，可以接受
3. 如果广告拦截使用枚举的方式和你死磕，好像没有什么好的办法，因为换一组盐，就要重新生成css文件，流量较为浪费。但至少可以通过换盐的方式让反屏蔽成功。如果不考虑流量损耗的话，补偿机制可以是定期换盐，和js检查广告并上报自动换盐。

总结：

算法不宜破解，会有流量的浪费，怕被枚举暴力破解【不会这么无聊吧。。。。】

# 方案3 全部使用行内样式

优势：

1. 毫无特征？？？

劣势：

1. 写代码挺费劲。。。
2. 如果js想操作元素，因为毫无特征，好像操作不了了。。。

总结

此路好像不通，毫无特征对业务js来说也是不行的。


