# ReactNative的架构设计

请注意，本篇写的是react native的架构设计，如果你用react来开发web程序，本篇文章只能仅供参考，问题都没有在web上去考虑过。

用RN最大的难题是设计思想的转变，以前的设计方法论已经不太适用了。而RN仅仅提供了view的框架，构建完整app的架构并没有直接提供。

考虑目前遇到的如下问题，希望架构给出解决方案。

1. 交互：如何解决组件间通信【父子、子父、兄弟等，特别是跨层or反向数据流动等】；用state还是接口操作组件；
3. 职责：组件状态放哪，业务逻辑放哪，数据放哪，因为太灵活了，怎么做都可以实现功能，但是怎么做才是最好的，才是最正确的呢？
4. 面向过程：由于react是面向状态编程，相当于react的组件只关注数据的最终状态，数据是怎么产生的并不关心，但是某些场景下，数据如何产生的是会影响到组件的一些行为的【比如一个新增行要求有动画效果，查询出的行就不需要等】，这在RN中很难描述。。。。。

RN架构就是为解决上述问题提供的指导和方法论，是通盘考虑整个开发、测试、运维的状况，做出的考虑最全面的抉择，或者为抉择提供依据。

目前为react服务的架构也有一些了，如Flux，Reflux，Redux，Relay，Marty。

##Flux
flux是官方提供的架构，目的是分层解耦，职责划分清晰，谁负责干啥很明确。具体描述可以参考官方文档，这里不详述。

1. action 封装请求
2. dispatcher 注册处理器、分发请求
3. store 是处理器，处理业务逻辑，保存数据
4. view 根据store提供的数据进行展现;接受用户的输入并发出action请求。


![](media/14500845993004.jpg)


数据流动：
Action-> Dispatcher -> Store -> Component

但我觉得解耦的太细了，干一个事，要做太多太多的额外工作了。

光注册监听动作就2次，一次是store注册到dispatcher，一次是view注册到store中。

而且，注册到dispatcher的监听应该都不叫注册，架构完全没有提供任何封装，直接暴露一个统一的回调方法，里面自行if else路由不同的store。


##Reflux
结构上与flux架构基本一致，去掉了flux的一些冗余操作【比如没有了dispatcher】，架构更加简洁和紧凑，用到了一些约定大于配置的理念。

基本上将flux的架构冗余都简化了，可以说是flux的去冗余提升版，但是没有本质的变化。

```
╔═════════╗       ╔════════╗       ╔═════════════════╗
║ Actions ║──────>║ Stores ║──────>║ View Components ║
╚═════════╝       ╚════════╝       ╚═════════════════╝
     ^                                      │
     └──────────────────────────────────────┘

```

1. 更容易的监听。listenables和约定以on开头的方法。等。
2. 去掉了dispatcher。
3. action可以进行aop编程。
4. 去掉了waitfor。store可以监听store。
5. component提供了一系列mixin，方便注册\卸载到store的监听和与store交互等。

##Redux

社区内比较受推崇，因为用起来相对比较简单


![](media/14502335830493.jpg)


特性：

1. 分层设计，职责清晰。
2. 要求store reducer都是页面单例，易于管理。
2. action为请求dto对象，是请求类型，请求数据的载体。
3. reducer是处理请求的方法。不允许有状态，必须是纯方法。必须严格遵守输入输出，中间不允许有异步调用。不允许对state直接进行修改，要想修改必须返回新对象。
4. store
	5. 维持应用的state；
	1. 提供 getState() 方法获取 state；
	2. 提供 dispatch(action) 方法分发请求来更新 state；门面模式，要求所有的请求满足统一的格式【可以进行路由、监控、日志等】，统一的调用方式。
	1. 通过 subscribe(listener) 注册监听器监听state的变化。
1. 官方文档写的较为详细，从设计到开发都有，比flux要好

痛处如下，看能否接受或者解决：

1. redux的原则1：state不能被修改。因为要做diff，所以源不能被动。
	2. 会产生很多奇怪的代码，很讨厌，比如修改数组的某一项，要新建一个数组，里面是：这项之前+修改后的一项+这项之后。。。。太难理解，如果写错了会产生bug的话，简直无法维护。参考地址：http://camsong.github.io/redux-in-chinese/docs/basics/Reducers.html
	3. 官方给的建议是：因为我们不能直接修改却要更新数组中指定的一项数据，这里需要先把前面和后面都切开。如果经常需要这类的操作，可以选择使用帮助类 React.addons.update，updeep，或者使用原生支持深度更新的库 Immutable。最后，时刻谨记永远不要在克隆 state 前修改它。
	4. **解决方案：**暂无啊啊啊。
4. 单一的庞大的reducer的拆分
	5. 这块设计也不好做，会让人疑惑
	6. 官方给的demo中直接按state的内容区分，我觉得这样做不好，如果后期有跨内容的情况，就比较奇怪了。官方给的combineReducers方案，也只是减少代码量，本质没有变化，state还是拆分处理，路由还是业务逻辑自己来做。
	7. **解决方案**：还是处理一整个state，可以按照约定写reducer类而不是方法，类里按照actionType建方法，架构自动路由并调用。
	8. 以前做java架构，路由一定是架构来调用的，目前感觉各大flux框架都是解决问题不彻底。
1. 官方建议设计模式：顶层容器组件才对redux有依赖，组件间通过props来传递数据。按照这样设计还是没有解决组件间交互和数据传递的问题。官方react设计建议：react的设计建议：http://camsong.github.io/redux-in-chinese/docs/basics/UsageWithReact.htm
2. 使用connect将state绑定到component。此处有些黑盒了。
2. 异步action用来请求服务端数据,利用middleware增强createStore的dispatch后即支持。

##Relay
没有时间，没做研究
##Marty
没有时间，没做研究

##结论

开源架构基本都没有考虑到通用组件和业务组件、页面的区分。

开源架构封装的简单的flux会产生较多的冗余代码。

开源架构封装的复杂的redux，有些概念不易理解。且其和RN绑定也封装了一些东西，是一个黑盒，不易维护。

介于上述两者之间的开源架构reflux，文档较上述2个少，不知道其可持续性如何。如果一定要用开源架构的话，我觉得他是一个较为推荐的选择。

不是特复杂的程序【一般spa的程序会更复杂一些，而RN并不是spa】，这些概念只会增加你的开发难度，并且对后面维护的人要求更高。

我们继续头脑风暴，继续抽象总结一下flux系列框架，

1. 目前的flux系列架构一般都是：view【用户输入or生命周期事件触发】->action->store【改变自己内部的modal】->view【根据modal，自行setState】
	2. view从接受到输入，到驱动store去改变，到store通知view去改变，从view接收输入到view变化绕了这么一大圈，有种脱裤子放屁的感觉
	3. 能不能简化？？？flux系列框架究竟想干什么？？？
1. flux系列框架干了什么，没干什么，针对开篇提出的问题。
	2. 【解决职责】解耦，分层，谁该干什么就干什么，不许干别的，让代码读起来更有预测性和一致性，方便维护
	3. 【解决职责】继续解耦，采用事件机制解决各层之间通信
	4. 【没有解决通信】并没有提供组件间通信问题的解决方案
	5. 【没有解决面向过程】并没有提供过程决定组件展现问题的解决方案

所以最后的结论是：不使用开源架构，借助其思想，自行封装更简单的架构。


## 理想情况是？

再次强调：目前仅考虑如何应用于react native

1. 针对开篇问题的解决方案
	1. 交互
		1. 组件对外只允许使用props来暴露功能，不允许使用接口即其它一切方式
		2. 组件的子组件可以直接操作其父组件的state或调用其接口等
	1. 职责
	2. 面向过程
3. 根据以上方案，进行通用组件设计
	4. 基本结构 
		5. root组件，子组件
		6. root组件中有
			1. props-公有属性
			2. state-RN体系的状态
			3. 私有属性
			4. 私有方法，子组件可以用
			5. 公有方法【不推荐】，子组件和外部组件都可以用，但不推荐用公有方法来对外发布功能，破坏了面向状态编程，尽可能的使用props来发布功能
		1. 子组件中有
			1. props-公有属性
			2. 私有属性-如果你不能理解，建议没有，统一放在父组件上
				3. 绝对不允许和父组件的属性or状态有冗余。无论是显性冗余还是计算结果冗余，除非你能确定结算是性能的瓶颈。
				4. 此属性只有自己会用，父组件和兄弟组件不会使用，如果你不确定这点，请把这个组件放到父组件上，方便组件间通信
			3. 私有方法
			4. 公有方法【不推荐，理由同root组件】 
	5. 子组件是否需要复用
		6. 需复用，只暴露props，内部自行管理state
		7. 不需复用，只暴露props，内部无state【因为不会单独使用，不需要setState来触发渲染】
		8. 一般按照不需复用的情况设计，除非复用很明确，但这时候应该提出去，变成独立的组件存在。
5. 根据以上方案，进行业务组件、页面设计


## 按场景分析、验证架构设计

触发view改变的场景【即需要setState的场景】

2. 回调函数触发【异步】
	2. 组件生命周期事件中or用户操作触发 启动请求服务器
	3. 组件生命周期事件中or用户操作触发，启动定时任务or注册了其它回调函数【比如交互管理器的动画结束事件】
4. 用户操作触发
	5. view的直接改变【同步】
	6. 仅仅注册回调函数【异步，参考上面一条】












